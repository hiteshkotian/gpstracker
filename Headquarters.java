import edu.rit.ds.registry.RegistryProxy;
import edu.rit.ds.RemoteEventListener;
import java.rmi.server.UnicastRemoteObject;
import edu.rit.ds.registry.RegistryEventListener;
import edu.rit.ds.registry.RegistryEvent;
import java.rmi.RemoteException;
import edu.rit.ds.registry.NotBoundException;
import edu.rit.ds.registry.RegistryEventFilter;

/**
 * Class Headquarters is the main GPS headquarter office which intercepts all
 * the routing messages of all the packages being sent in the system.
 * 
 * Class Customer also has a main program that takes the user input. 
 * Usage() : java Headquarters <host> <port>. 
 * <host> : Name of the host computer where the Registry Server is running. 
 * <port> : Port number to which the Registry Server is listening.
 */
public class Headquarters {

	/**
	 * RegistryProxy object.
	 */
	private static RegistryProxy registry;

	/**
	 * RemoteEventListener object to listen to any DeliveryEvent that the
	 * GPSOffice is generating.
	 */
	private static RemoteEventListener<DeliveryEvent> nodeListener;

	/**
	 * RegistryEventListener object to listen to any events generated by the
	 * objects registered in the registry.
	 */
	private static RegistryEventListener registryListener;

	/**
	 * RegistryEventFilter object to filter out the DeliveryEvent sources.
	 */
	private static RegistryEventFilter registryFilter;

	/**
	 * Main program of class Headquarters.
	 */
	public static void main(String[] args) throws Exception {

		// If the required number of arguments are not entered by the user,
		// then print the usage for the Headquarters class and exit.
		if (args.length != 2) {
			usage();
		}

		// Get all the values from the command line argument.
		String host = args[0];
		int port = parseInteger(args[1], "port");

		// Instantiate the RegistryProxy object on the host and port specified.
		registry = new RegistryProxy(host, port);

		// Instantiate the RegistryEventListener object to listen to the
		// RemoteEvent subclass objects passed in the registry.
		registryListener = new RegistryEventListener() {
			public void report(long seqnum, RegistryEvent event) {
				listenToNode(event.objectName());
			}
		};

		// Export the RegistryListener to the registry.
		UnicastRemoteObject.exportObject(registryListener, 0);

		// Instantiate the RemoteEventListener to listen to any events of type
		// DeliveryEvent.
		nodeListener = new RemoteEventListener<DeliveryEvent>() {
			// In case an event is caught the headquarters will just print the
			// delivery notification of the event.
			public void report(long seqnum, DeliveryEvent event) {
				System.out.println(event.deliveryNotification);
			}
		};

		// Export the RemoteEventListener object to the registry.
		UnicastRemoteObject.exportObject(nodeListener, 0);

		// Instantiate the RegistryEventFilter object that will filter out the
		// Events generated
		// by the GPSOffice.
		registryFilter = new RegistryEventFilter().reportType("GPSOffice")
				.reportBound();
		// Add the event listeners to the RegistryServer.
		registry.addEventListener(registryListener, registryFilter);

		// For all objects in the registry of type GPSOffice, make the client
		// listen to them
		// so that any RemoteEvents generated by them could be intercepted by
		// the client.
		for (String objectName : registry.list("GPSOffice")) {
			listenToNode(objectName);
		}
	}

	/**
	 * Function that returns a string that tells the user how the program is
	 * expected to be compiled and also explains what each command line argument
	 * stands for.
	 */
	public static void usage() {
		String usageString = "\nUsage() : " + "java Headquarters <host> "
				+ "<port>\n";
		usageString += "<host> : Name of the host computer where"
				+ " the Registry Server is running.\n";
		usageString += "<port> : Port number to which the"
				+ " Registry Server is listening.\n";
		System.exit(1);
	}

	/**
	 * Function that converts the string parameter to an integer and returns the
	 * value.
	 * 
	 * @param value
	 *            String value to be parsed as an integer.
	 * @param arg
	 *            The name of the argument for which the value is parsed as an
	 *            integer.
	 * 
	 * @return int The integer value after being parsed from the string.
	 * 
	 * @exception NumberFormatException
	 *                Thrown when the String value cannot be parsed as an
	 *                Integer.
	 */
	public static int parseInteger(String argument, String value) {
		try {
			return Integer.parseInt(argument);
		} catch (NumberFormatException exc) {
			throw new IllegalArgumentException("<" + value + "> = " + argument
					+ " : Is not an Integer");
		}
	}

	/**
	 * Function which enables the headquarters object to listen to the object
	 * registered in the registry.
	 * 
	 * @param objectName
	 *            Name of the object in the registry.
	 */
	private static void listenToNode(String objectName) {
		try {
			GPSInterface gpsNode = (GPSInterface) registry.lookup(objectName);
			gpsNode.addListener(nodeListener);
		} catch (NotBoundException exc) {

		} catch (RemoteException exc) {

		}
	}

}